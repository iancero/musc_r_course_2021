[["basic-r.html", "3 Basic R 3.1 Writing in R and Rmarkdown 3.2 Variables 3.3 Vectors 3.4 Lists 3.5 Dataframes 3.6 Functions 3.7 Packages 3.8 Error messages 3.9 Coding Conventions", " 3 Basic R 3.1 Writing in R and Rmarkdown 3.1.1 Chatting with R Using R is just a chat with the computer. Hey, R. What is \\(1 + 2\\)? 1 + 2 ## [1] 3 3.1.2 Rmarkdown tricks To make text bold, we add two **s around it. To make text italicized, we add just one * around it. If we need special characters (like * or $), then we just add a forward \\ in front of them (but not behind). Math symbols in your text are process with Latex, just put an $ before and after your math. Like this, $y = x$ becomes \\(y = x\\). 3.1.3 Code blocks To make a code block, press CTRL+ALT+I. banana &lt;- 5 banana + 1 ## [1] 6 3.2 Variables Variables are values that I want to give names to and save for later. 3.2.1 The assignment operator We make variables with the &lt;- operator. This is called the assignment operator because it assigns values on the right to names on the left. If I want to know what the value of a variable is, I can run it alone on its own line. my_special_var &lt;- 1 + 2 my_special_var ## [1] 3 You can TECHNICALLY use = for assignment too. Never do this. my_other_var = 12 my_other_var + my_special_var ## [1] 15 The = symbol gets also used for a few other things in R. So, using it to assign variables will make your code more confusing to you, when you go back to read it over later. 3.2.2 Numerics Doubles Doubles are decimal numbers, like \\(1.1, 2.2, 3.0\\). If I make a number variable without doing anything special, R defaults to a double. a &lt;- 1.1 b &lt;- 2.0 is.double(a) ## [1] TRUE is.double(b) ## [1] TRUE Integers Integers must have an L after them. That is how R knows that you dont want a double, but instead want a long-capable integer. c &lt;- 1L d &lt;- 1 is.integer(c) ## [1] TRUE is.integer(d) ## [1] FALSE Here is a useful cheatsheet for the different numeric operators and how they behave. Operator Expression Result + 10 + 3 13 - 10 - 3 7 * 10 * 3 30 / 10 / 3 3.333 ^ 10 ^ 3 1000 %/% 10 %/% 3 3 %% 10 %% 3 1 Why care about the difference? Almost 99% of the time, this wont matter. But, with big data, integers take up must less memory. my_integers &lt;- seq(from = 1L, to = 1e6L, by = 1L) my_doubles &lt;- seq(from = 1.0, to = 1e6, by = 1.0) object.size(my_integers) ## 4000048 bytes object.size(my_doubles) ## 8000048 bytes Note here that although we are using only whole numbers from 1 to 1 million, the first sequence (my_integers) is stored as an integer and the second sequence (my_doubles) is stored as a number that may include decimals. This second case needs more space (twice as much) to be allocated in advance, even if we never use those decimal places. Again, this will almost never matter for most people, most of the time. However, it is good to be aware of for when your datasets get large (i.e., several million cases or more). 3.2.3 Characters Characters are text symbols and they are made with either \"\" or '', either works. a &lt;- &#39;here is someone\\&#39;s text&#39; b &lt;- &quot;here is more text&quot; a ## [1] &quot;here is someone&#39;s text&quot; b ## [1] &quot;here is more text&quot; To combine two strings, I use paste(). paste(a, b) ## [1] &quot;here is someone&#39;s text here is more text&quot; If I dont want a space, then I used paste0(). paste0(a, b) ## [1] &quot;here is someone&#39;s texthere is more text&quot; 3.2.4 Booleans These are True and False values. You make them with the symbols T or TRUE and F or FALSE. x &lt;- T y &lt;- F To compare them, we can use three operators. &amp; is and | is or ! is not (just give me the opposite of whatever is after me) x &amp; y # false ## [1] FALSE x | y # true ## [1] TRUE x &amp; !y # true ## [1] TRUE We can also have nested equations z &lt;- F x &amp; !(y | z) # true ## [1] TRUE We can also compare numbers. a &lt;- 1 b &lt;- 2 a &lt; 1 ## [1] FALSE a &lt;= 1 ## [1] TRUE a == 1 ## [1] TRUE If I want to compare multiple numbers, I need to do it seperately. (a &gt; 1) | (b &gt; 1) ## [1] TRUE Remember that booleans are ultimately numeric values underneath. d &lt;- T k &lt;- F u &lt;- 5 d*u ## [1] 5 d*k ## [1] 0 as.numeric(d) ## [1] 1 as.numeric(k) ## [1] 0 3.2.5 Special types NA - missing is.na(NA) ## [1] TRUE NaN - you did math wrong 0/0 ## [1] NaN Inf - infinity -5/0 ## [1] -Inf 3.3 Vectors R is built is on vectors. Vectors are collections of a bunch of values of the same type. my_vec &lt;- c(1, 5, 3, 7) my_vec ## [1] 1 5 3 7 If I try to put different types together, they go to the most primitive type (usually a character string). my_other_vec &lt;- c(22, &#39;orange&#39;, T) my_other_vec ## [1] &quot;22&quot; &quot;orange&quot; &quot;TRUE&quot; my_third_vec &lt;- c(T, F, 35) my_third_vec ## [1] 1 0 35 We can also missing values. my_fourth_vec &lt;- c(1, 4, 5, NA) my_fourth_vec ## [1] 1 4 5 NA is.na(my_fourth_vec) ## [1] FALSE FALSE FALSE TRUE If I want to combine two vectors a &lt;- c(1, 2, 3) b &lt;- c(3, 5, 7) c(a, b) ## [1] 1 2 3 3 5 7 A brief example of matrices matrix( data = c(a, b), nrow = 2, byrow = T) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 3 5 7 Sometimes I want special vectors, direct sequences of numbers. There are two ways to do this. If all I want is a integer sequence (made of doubles), then I use the &lt;first number&gt;:&lt;last number&gt;. 1:5 ## [1] 1 2 3 4 5 5:1 ## [1] 5 4 3 2 1 Other times, I need to count by something other than one, so I use seq(from = &lt;start&gt;, to = &lt;end&gt;, by = &lt;number to count by&gt;) seq(from = 1, to = 7, by = 1.3) ## [1] 1.0 2.3 3.6 4.9 6.2 Hint: for brevity, I can leave off function parameter names, as long as I enter them in order seq(1, 7, by = 1.3) ## [1] 1.0 2.3 3.6 4.9 6.2 If I add a constant to a vector, then they all go up by that constant. 1:5 / 3 ## [1] 0.3333333 0.6666667 1.0000000 1.3333333 1.6666667 I can do math with equal-length sequences too. 1:5 - seq(1, 4, by = .7) ## [1] 0.0 0.3 0.6 0.9 1.2 But they must be equal lengths. 1:5 / 1:4 ## Warning in 1:5/1:4: longer object length is not a multiple of shorter object length ## [1] 1 1 1 1 5 To access the elements of a vector, I put a number OR booleans in brackets []. my_vec &lt;- c(&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;pair&#39;) my_vec[2] ## [1] &quot;orange&quot; my_vec[2:4] ## [1] &quot;orange&quot; &quot;banana&quot; &quot;pair&quot; my_vec[c(3, 2, 1, 4)] ## [1] &quot;banana&quot; &quot;orange&quot; &quot;apple&quot; &quot;pair&quot; I can also use bools. my_other_vec &lt;- c(1, 4, 6, 7, 9, 3, 9) my_other_vec &lt; 5 ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE my_other_vec[my_other_vec &lt; 5] ## [1] 1 4 3 I can also use functions that return values to access vectors, if I am creative my_other_vec[max(my_other_vec) == my_other_vec] ## [1] 9 9 R also has special vectors that are pre-loaded. The most commonly used are letters and LETTERS, which return the lower-case letters and uppercase letters of the English alphabet, respectively. vec &lt;- c(1, 3, 4, 5, 3, 2, NA) mean(vec, na.rm = T) ## [1] 3 3.4 Lists &lt;&lt; More on lists to come &gt;&gt; Lists are special vectors that can hold multiple types of elements, even vectors my_vec &lt;- c(4, 5, 6) my_list &lt;- list(1, &#39;banana&#39;, 3, NA, my_vec) my_list ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;banana&quot; ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] NA ## ## [[5]] ## [1] 4 5 6 3.5 Dataframes 3.5.1 Construction Dataframes are spreadsheets. Under the hood of R, they are just lists of vectors, where all the vectors are required to be the same length. To make one, you can call the data.frame() function and put your vectors inside. heights &lt;- c(60, 65, 71, 72, 64) sexes &lt;- c(&#39;female&#39;, &#39;female&#39;, &#39;male&#39;, &#39;male&#39;, &#39;female&#39;) shoes &lt;- c(&#39;Adidas&#39;, &#39;Nike&#39;, &#39;Nike&#39;, &#39;Salvatore Ferragamo&#39;, &#39;Reebok&#39;) df &lt;- data.frame(height = heights, sex = sexes, shoes = shoes) df ## height sex shoes ## 1 60 female Adidas ## 2 65 female Nike ## 3 71 male Nike ## 4 72 male Salvatore Ferragamo ## 5 64 female Reebok 3.5.2 Built-in dataframes R has numerous built-in datasets that are ideal for demonstration purposes. We can get access to them using the data() command. This will load the data into our session, so we can then look at it. data(&#39;mtcars&#39;) mtcars ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Some datasets do not come in the form of a dataframe right away, but they can be converted into one using the as.data.frame() function. data(Seatbelts) is.data.frame(Seatbelts) ## [1] FALSE seatbelts_df &lt;- as.data.frame(Seatbelts) is.data.frame(seatbelts_df) ## [1] TRUE 3.6 Functions A function is a piece of code that does work for you. It takes inputs and (usually) returns outputs. For example, the sum() function takes the sum of a numeric vector. my_vec &lt;- c(3, 6, 2, 3) sum(my_vec) ## [1] 14 3.6.1 Getting help If I ever need to know something about a function, I can put a question mark in front of it (no ()s) and run that line. That will bring up the help document for that function. ?sum 3.6.2 Function parameters In addition to the data they take as input, most functions have additional parameters (sometimes called arguments, but they mean the same thing). Looking at its help file, the sum() function has two parameters: ..., the numbers you want to sum na.rm = FALSE, which tells sum() whether you want to remove (rm) missing values (na) before summing. Lets look at what happens when we try to sum() a vector with a missing value. my_vec &lt;- c(5, NA, 2, 3) # should be 10 sum(my_vec) ## [1] NA R tells us the answer is missing (NA) because at least one of the vector elements is missing. This is to be conservative and to force you never to ignore missing values by accident. But what do we do if we really do want to sum all available values, ignoring the missing values. Again, looking at the help file, we can see that the na.rm parameter of the function is followed by = FALSE, under the Usage heading of that help document (look for sum(..., na.rm = FALSE)). This tells us that the parameter na.rm, which tells sum() whether to remove missing values from the calulation, defaults to FALSE. To get sum() to ignore the missing values in our vector, we simply set na.rm to TRUE (or T for short). sum(my_vec, na.rm = T) # should be 10 ## [1] 10 3.7 Packages Packages are collections of functions that someone else put together for you. You can install them using the install.packages() function, with the name of your package inside the () - dont forget to use either single (' ') or double quotes (\" \") around the package name too. install.packages(&#39;ggplot2&#39;) Once installed, use the library() function to load your package into your R session. Note, you dont need quotes here. library(ggplot2) 3.8 Error messages Whenever R detects that something has gone wrong, it will send you an error message in the form of some scary-looking red text. &#39;100&#39; / &#39;2&#39; # trying to divide two strings ## Error in &quot;100&quot;/&quot;2&quot;: non-numeric argument to binary operator Unfortunately, R is not especially smart and is usually bad at detecting exactly WHAT has gone wrong. In this case, all it knows is that / needs two numbers - one on either side - to work correctly. It detected something other than that, which is what it told us: there was a non-numeric argument (input) SOMEWHERE on either side of the / symbol. Stumbling on an error and getting stuck is especially common. Its also common to get frustrated when you are stuck with the same error for more than a few minutes. For that reason, if you cant solve an error after a few quick tries, its best NOT to beat your head against the wall. Instead, go to a place like https://stackoverflow.com/, which is a website devoted entirely to answering questions - most of which are about coding errors just like yours. Simply copy and paste your error into the search box and look for someone who asked your question already. Youll notice that many people have had your same problem and have even produced some code you can copy/paste to fix your current issue. 3.9 Coding Conventions R is a language, much like English or Spanish. It sometimes has rules for how you MUST say something in order for your computer to understand at all. For example, R wont let you add a number and a letter together because that wouldnt make sense mathematically. 1 + &#39;a&#39; ## Error in 1 + &quot;a&quot;: non-numeric argument to binary operator Other times, R will let you do the same thing in more than one way. For example, I can name my variables with a mixture of capitals and lower-case letters. apple &lt;- 123 BANANANA &lt;- 456 ClEmEnTiNe &lt;- 789 Some of these options might be more confusing than others, but R will technically let you do them. Other examples include using &lt;- or = to assign values to variables. As discussed above, both with work. peas &lt;- &#39;tasty&#39; carrots = &#39;also tasty&#39; 3.9.1 What should my code look like? Whenever there are multiple options for how to code, its worth thinking about whether one will be better for you than the others. If you come up with a consistent rule over time - like never use capital letters in function names - youve developed some coding conventions. These achieve a few things for you, but mostly we develop these informal language rules for clarity. They make it easier for us to read our code, and for others to understand what we were doing when they look at our code later. Some common coding conventions most R users now employ are given below. 3.9.1.1 Common coding conventions in R Never use = to assign variable values. Use the &lt;- operator instead because it is more clear. a = 2 # bad a &lt;- 2 # good Avoid using . to seperate words in your variable and function names because this makes it hard for people who come from other coding langauages to understand us. Use _ instead. my.favorite.number &lt;- 3.14159 # bad my_favorite_number &lt;- 3.14159 # good Whenever possible, stick to lower-case variable names. It will make it easier for you to reference your variables later, without accidentally making a capitalization error. apple &lt;- 123 # good BANANANA &lt;- 456 # bad ClEmEnTiNe &lt;- 789 # bad Whenever possible, try to use single-quotes (') for character strings, rather than double quotes (\"). Single quotes are easier on your eyes when you are looking at a page full of code. peas &lt;- &quot;tasty&quot; # bad carrots = &#39;also tasty&#39; # good 3.9.2 Official coding conventions Coding conventions are so important, that many people have tried to publish some. You can think of these like stlye guides that many people agreed to use. The one most relevant to our own work here is Hadley Wickhams guide at https://style.tidyverse.org/. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
